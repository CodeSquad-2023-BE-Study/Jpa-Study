# 일대다

### 일대다 페치 조인을 하면 중복 데이터가 발생된다.

### 중복 데이터를 제거하는 방법

1. JPQL Select Distinct로 가져오기

- SQL의 Distinct와 다르다?

Distinct는 모든 필드가 같은 데이터를 제거하는 것인데 페치조인한 데이터는 한 필드는 다르다.

- 다른 객체 그래프를 탐색하는 경우 Select Distinct로 제거되지 않는다.

예를 들면, (경험담) BusinessHours ↔ StoreMeta ↔ StoreDetail와 같은 경우,

StoreDetail에서 StoreMeta, BusinessHours를 FetchJoin하여 가져왔을 때 중복이 제거되지 않는다. 

1. Set을 이용하기

Set으로 데이터를 가져온다면 중복을 효과적으로 제거할 수 있다. 그렇지만 List 대신 Set을 사용할 때 유의해야한다.

- Set을 사용할 때 유의할 점?

Set은 순서가 없는 자료구조이므로 Set으로 데이터를 가져올 때는 어플리케이션 레벨에서 정렬해주어야한다.

1. @BatchSize로 한번에 지연로딩하기

Member 1,2,3 X Team 1,2,3인 경우 fetch Join시 중복 데이터 발생, Team을 다 가져온 후 지연 로딩하면 2번의 쿼리로 중복데이터 없이 가져올 수 있다.

N+1 → 테이블의 개수 + 1 개만큼

### 일대다 페치 조인은 페이징을 할 수 없다.

간단하게 아래의 예시를 페이징한다고 생각해보자. 일대다는 데이터의 개수가 뻥튀기되기 때문에, 중복을 제거하기 전의 데이터로는 제대로 된  페이징을 할 수 없다. 따라서 JPA에서 일대다 페치조인을 페이징하면 하이버네이트가 자동으로 메모리에 로딩하여 중복을 제거한 후 페이징을 하게되는데, 이는 매우매우 위험하다. 쿼리의 결과를 메모리에 로딩하는데, 서버 장애나기 쉬운 상황이라고 한다. 

| Team ID | Member ID |
| --- | --- |
| 1 | 1 |
| 1 | 2 |
| 1 | 3 |
| 2 | 1 |
| 2 | 2 |
| 2 | 3 |

| Team ID | Member ID | Game ID |
| --- | --- | --- |
| 1 | 1 | 1 |
| 1 | 2 | 1 |
| 1 | 3 | 1 |
| 2 | 1 | 2 |
| 2 | 2 | 2 |
| 2 | 3 | 2 |
|  |  |  |

### 일대다 페치 조인은 한번만 할 수 있다?

JPA에서는 oneToMany를 2개 이상 List로 매핑할 수 없다. 매핑하려고 하는 경우 MultipleBagFetchException이 발생한다.

ex)

Team이 List<Member>와 List<Game>을 가지는 경우를 생각해보자.

위의 경우처럼 Cartesian Product만큼 데이터가 복사된다. 따라서 JPA는 예외를 발생시키는데, 이는 바뀌는 필드가 2개 이상이 되면 매핑을 할 기준이 없어지기 때문이다.

하지만 둘 중 하나를 Set으로 바꾼다면 예외가 발생되지 않는다. Member를 Set으로 받는다고 생각해보자. 

| Team ID | Member(Set) | Game ID |
| --- | --- | --- |
| 1 | 1,2,3 | 1 |
| 1 | 1,2,3 | 2 |
| 1 | 1,2,3 | 3 |

위 경우처럼 훨씬 문제가 단순해진다.

다른 해결방법은, fetch Join을 할 때 엔티티 그래프를 가능한 다른 방향으로 설정하는 것이다. 혹은, fetch Join을 여러번 나누어서 실행하는 방법, Batch Size를 이용하는 방법 등이 있겠다.
